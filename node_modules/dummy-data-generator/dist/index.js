"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const en_1 = require("@faker-js/faker/locale/en");
const camelCase_1 = tslib_1.__importDefault(require("lodash/camelCase"));
const createData_1 = require("./createData");
const mainValidation_1 = require("./validation/mainValidation");
const subValidation_1 = require("./validation/subValidation");
const getCSV = (jsonArray) => {
    const items = jsonArray;
    const header = Object.keys(items[0]);
    const csv = [
        header.join(","),
        ...items.map((row) => header.map((fieldName) => JSON.stringify(row[fieldName])).join(",")),
    ].join("\r\n");
    return csv;
};
const getDummyValue = (type, length, values) => {
    switch ((0, camelCase_1.default)(type)) {
        case "word": {
            return (0, createData_1.createWord)(length);
        }
        case "paragraph": {
            return (0, createData_1.createParagraph)(length);
        }
        case "name": {
            return en_1.faker.name.findName();
        }
        case "enum": {
            const possibleValues = values
                ? values.map((el) => String(el))
                : getDummyValues(length);
            const random = Math.floor(Math.random() * possibleValues.length);
            return possibleValues[random];
        }
        case "date": {
            return en_1.faker.date.recent().toString();
        }
        case "randomNumber": {
            return en_1.faker.datatype.number();
        }
        case "randomNumberOfGivenLength": {
            return (0, createData_1.randomNumber)(length);
        }
        case "url": {
            return String(en_1.faker.internet.url());
        }
        case "domainName": {
            return String(en_1.faker.internet.domainName());
        }
        case "email": {
            return String(en_1.faker.internet.exampleEmail());
        }
        case "ipAddress": {
            return String(en_1.faker.internet.ip());
        }
    }
};
const getDummyValues = (length) => {
    const arrayData = [];
    for (let index = 0; index < length; index++) {
        arrayData.push((0, createData_1.createWord)(length));
    }
    return arrayData;
};
const generateOneObject = (columnData) => {
    const columnNames = Object.keys(columnData);
    let data = {};
    columnNames.forEach((columnName) => {
        let { type, length } = columnData[columnName];
        const { values } = columnData[columnName];
        type = type ? type : "word";
        length = length ? Number(length) : 5;
        data = Object.assign(Object.assign({}, data), { [columnName]: getDummyValue(type, length, values) });
    });
    return data;
};
/**
 * Returns a Array of JSON Object of the columns provide.
 * If @param {boolean} isCSV is set true, then it will return
 * a string in CSV format
 *
 * @param {string} columnData - A JSON Object with keys as required columns name and value with type and length of the dummy text.
 * @param {number} count - Number of Object/rows needed.
 * @param {boolean} isCSV - is CSV format needed?

 * @returns { string | ObjectData[]}
 */
const dataGenerator = ({ columnData, count = 1, isCSV = false, }) => {
    if ((0, mainValidation_1.mainValidationSchema)(columnData) !== true) {
        return new Error(JSON.stringify((0, mainValidation_1.mainValidationSchema)(columnData), null, 2));
    }
    let isSubValid = true;
    Object.entries(columnData).map(([, value]) => {
        if ((0, subValidation_1.subValidationSchema)(value) !== true) {
            isSubValid = (0, subValidation_1.subValidationSchema)(value);
        }
    });
    if (isSubValid !== true) {
        return new Error(JSON.stringify(isSubValid, null, 2));
    }
    let finalData = [];
    for (let index = 0; index < count; index++) {
        finalData = [...finalData, generateOneObject(columnData)];
    }
    return isCSV ? getCSV(finalData) : finalData;
};
exports.default = dataGenerator;
//# sourceMappingURL=index.js.map